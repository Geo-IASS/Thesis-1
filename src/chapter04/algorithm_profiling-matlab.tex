%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Introduction}
\label{profiling:matlab:introduction}
Using the \software{MATLAB} \command{profile} command, I was able to analyse and
profile the \algm{anomaly detection using commute distance} algorithm and make
an assessment of the running time of the algorithm. By analysing the code in
order to determine which regions are most limiting to the algorithm's
performance, I was able to determine an ideal candidate function for a hardware
implementation. The results of the algorithm profiling appear in the following
sections.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Method
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Method}
\label{profiling:matlab:method}
In order to profile the provided \software{MATLAB} code, it was necessary to
gain a basic understanding of the structure of the source code, as well as
insight into how the algorithm is intended to be used (i.e.\ pre-conditions,
post-conditions, etc.).

In order to facilitate later testing of other algorithm implementations, the
decision was made to modify the original code so as to provide more verbose
logging, as well as ensuring that all variables and plots that were produced by
the algorithm were stored on the file system. Furthermore, the original
\command{TopN_Outlier_Pruning_Block} function was revised, adding minor
optimizations as well as improving the code's aesthetics. The \software{MATLAB}
code for the \command{TopN_Outlier_Pruning_Block} function that was used for
profiling can be found in \autoref{sourceCode:matlab}.

The algorithm profiling was performed on all data set instances so as to gain a
comprehensive insight into the strengths and deficiencies of the chosen
algorithm. The \software{MATLAB} \command{profile} command records information
regarding execution time, number of calls, parent functions, child functions,
code line hit count and code line execution time. This data is collected in
real-time during the algorithm's execution and is prepared into a report at
program completion. The timing information that is recorded by the
\command{profile} command relates to \gls{CPU} time --- that is, to the amount
of time for which the \gls{CPU} was used for processing instructions of the
code. This timing information, contrary to \emph{real} time, discounts idle
\gls{CPU} cycles that are caused as a result of \gls{IO} operations.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Results
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results}
\label{profiling:matlab:results}
The following plots compare the `self time' of functions comprising the
\algm{anomaly detection using commute distance} algorithm. Self time is a more
relevant metric than total time, as total time is a cumulative measure that
includes all self times of functions called by some outer function. Self time,
on the other hand, is the time spent \emph{in} a function excluding the time
spent in its child functions. Self time also includes overhead resulting from
the process of profiling.

It is my aim to select a single function as a candidate for a hardware
implementation, selecting the function that has the most significant impact on
the total algorithm execution time. As such, functions with a relatively small
self time need not be considered, and have been excluded from the following
plots. Specifically, any function with a self time less than 3\% of the total
execution time has been aggregated and is represented in the plots as ``Other''
functions.

The legend shown in \autoref{profiling:matlab:legend} is common amongst all of
the \software{MATLAB} profiling results plots shown in
\autoref{fig:profiling:matlab}.

\begin{figure}
    \centering
    \input{plots/matlab/legend}
    \caption{Common legend for MATLAB profiling plots}
    \label{profiling:matlab:legend}
\end{figure}
\input{plots/matlab/all_datasets}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Discussion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Discussion}
\label{profiling:matlab:discussion}
From observations of the results of the algorithm profiling, it was observed
that the performance of the \algm{anomaly detection using commute distance}
algorithm is bottle-necked significantly by the function named
\command{TopN_Outlier_Pruning_Block}. The \software{MATLAB} code for this
function can be found in \autoref{sourceCode:matlab}.

Analysis of this function, as well as discussions with \citeauthor{Khoa:2012}
revealed that the algorithm was originally devised by \citeauthor{Bay:2003} and
published in the paper \citetitle{Bay:2003}. The general steps of the algorithm
are described in \autoref{algm:TopNOutlierPruningBlock}. The function itself
will be discussed in \autoref{profiling:function}.

More specifically, it was apparent that within the
\command{Top_N_Outlier_Pruning_Block} function, there was a single step that
dominated valuable \gls{CPU} cycles. This step was the calculate of the square
of the Euclidean distance between two multidimensional vectors. Due to the
``nested for loop'' structure of the algorithm, there were a significant number
of calls to the \command{distance_squared} function. For one particular data
set, the \dataset{connect4} data set, calls to the \command{distance_squared}
function accounted for 43.3\% of all function calls made throughout the
algorithm's execution.

The extensive and repeated use of the \command{distance_squared} function, as
well as the simple structure of the function itself, provide initial confidence
that the \algm{anomaly detection using commute distance} algorithm could be
improved, in terms of performance and resource utilisation, through a hardware
design.